name: Publish to Public Repository

# Trigger options:
# 1. On GitHub release published (automatic after auto-release.yaml creates release)
# 2. On push to 'ready-for-public' branch (create this branch with protections)
# 3. Manual trigger via GitHub Actions UI
#
# NOTE: We trigger on 'release' events instead of 'push: tags' because
# the auto-release workflow uses GITHUB_TOKEN to push tags, which won't
# trigger other workflows (GitHub security feature to prevent infinite loops).
# By triggering on 'release' events, we run automatically when the GitHub
# release is created.

on:
  release:
    types: [published]  # Triggers when auto-release.yaml creates a GitHub release
  workflow_call:  # NEW
    inputs:
      tag_name:
        required: true
        type: string

  push:
    branches:
      - 'ready-for-public'  # Protected branch for controlled releases
  workflow_dispatch:    # Manual trigger from GitHub UI
    inputs:
      tag_name:
        description: 'Tag name (e.g., v0.5.13) - optional, defaults to current HEAD'
        required: false
        type: string

env:
  PUBLIC_REPO: 'ericscheier/emburden'
  PUBLIC_BRANCH: 'main'

jobs:
  validate-cran:
    name: CRAN Validation (Private Repo)
    runs-on: ubuntu-latest
    # Only run CRAN validation for version tags
    if: |
      (github.event.release.tag_name != '' && startsWith(github.event.release.tag_name, 'v')) ||
      (inputs.tag_name != '' && startsWith(inputs.tag_name, 'v'))

    steps:
      - name: Detect tag
        id: tag
        run: |
          if [ -n "${{ github.event.release.tag_name }}" ]; then
            TAG="${{ github.event.release.tag_name }}"
          elif [ -n "${{ inputs.tag_name }}" ]; then
            TAG="${{ inputs.tag_name }}"
          else
            TAG=""
          fi
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT
          echo "Validating tag: $TAG"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.tag.outputs.tag_name }}
          fetch-depth: 0

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: 'release'
          use-public-rspm: true

      - name: Setup R dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::rcmdcheck
          needs: check

      - name: Run CRAN checks (dry-run)
        run: |
          echo "üîç Running CRAN validation on private repo before publishing..."
          Rscript -e "
            results <- rcmdcheck::rcmdcheck(
              path = '.',
              args = c('--as-cran', '--no-manual'),
              error_on = 'warning',
              check_dir = 'check'
            )
            print(results)
          "

      - name: Upload check results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: private-cran-check-results
          path: check/

  publish:
    name: Clean and publish to public repository
    runs-on: ubuntu-latest
    needs: [validate-cran]
    # Run if CRAN validation passed OR if not a version tag (skip validation for branch pushes)
    if: |
      always() &&
      (needs.validate-cran.result == 'success' || needs.validate-cran.result == 'skipped')
    environment:
      name: public-release
      url: https://github.com/${{ env.PUBLIC_REPO }}

    steps:
      - name: Detect tag name from input or event
        id: detect_tag
        run: |
          # Priority: workflow_dispatch/workflow_call input > tag event > branch
          if [ -n "${{ inputs.tag_name }}" ]; then
            TAG_NAME="${{ inputs.tag_name }}"
            echo "Source: workflow input"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "Source: tag event"
          else
            TAG_NAME=""
            echo "Source: branch (no tag)"
          fi

          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "is_tag=$( [ -n \"$TAG_NAME\" ] && echo \"true\" || echo \"false\" )" >> $GITHUB_OUTPUT
          echo "is_version_tag=$( [[ \"$TAG_NAME\" == v* ]] && echo \"true\" || echo \"false\" )" >> $GITHUB_OUTPUT

          if [ -n "$TAG_NAME" ]; then
            echo "Detected tag: $TAG_NAME"
          else
            echo "No tag detected - will publish current branch"
          fi

      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.detect_tag.outputs.tag_name || github.ref }}
          fetch-depth: 0  # Full history for proper git operations
          persist-credentials: false  # Don't persist GitHub Actions token

      - name: Configure git
        run: |
          git config user.name "Eric Scheier"
          git config user.email "eric@scheier.org"

      - name: Install git-filter-repo
        run: |
          python3 -m pip install --user git-filter-repo

      - name: Filter AI attributions from commit messages
        run: |
          echo "Rewriting commit history to remove AI attributions..."

          # Create Python script to filter commit messages
          cat > /tmp/filter-commit-messages.py <<'PYTHON_EOF'
          #!/usr/bin/env python3
          import re
          import sys

          # Read the commit message
          message = sys.stdin.buffer.read().decode('utf-8')

          # Remove AI attribution lines
          # Pattern 1: Full attribution block with emoji and Co-Authored-By
          message = re.sub(r'\n\nü§ñ Generated with \[Claude Code\]\(https://claude\.com/claude-code\)\n\nCo-Authored-By: Claude <noreply@anthropic\.com>\n?', '', message)

          # Pattern 2: Just the Claude Code line
          message = re.sub(r'\n\nü§ñ Generated with \[Claude Code\]\(https://claude\.com/claude-code\)\n?', '', message)

          # Pattern 3: Just the Co-Authored-By line
          message = re.sub(r'\n\nCo-Authored-By: Claude <noreply@anthropic\.com>\n?', '', message)

          # Clean up any trailing whitespace and multiple blank lines
          message = re.sub(r'\n\n\n+', '\n\n', message)
          message = message.rstrip() + '\n'

          # Output the cleaned message
          sys.stdout.buffer.write(message.encode('utf-8'))
          PYTHON_EOF

          chmod +x /tmp/filter-commit-messages.py

          # Apply filter to all commits
          ~/.local/bin/git-filter-repo --force \
            --commit-callback "$(cat <<'CALLBACK_EOF'
          import subprocess

          # Get the original message
          original_msg = commit.message.decode('utf-8')

          # Filter it through our Python script
          result = subprocess.run(
              ['/tmp/filter-commit-messages.py'],
              input=original_msg.encode('utf-8'),
              capture_output=True
          )

          # Update the commit message
          commit.message = result.stdout
          CALLBACK_EOF
          )"

          echo "‚úì Commit history rewritten - AI attributions removed"

      - name: Clean repository for public release
        run: |
          echo "Cleaning repository for public distribution..."

          # Remove .private/ directory
          if [ -d ".private" ]; then
            rm -rf .private/
            echo "‚úì Removed .private/ directory"
          fi

          # Remove log files
          find . -name "*.log" -type f -delete 2>/dev/null || true
          echo "‚úì Removed *.log files"

          # Remove cache directories
          find . -name "*_cache" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "‚úì Removed *_cache directories"

          # Remove output directories
          find . -name "*_files" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "‚úì Removed *_files directories"

          # Remove private-only workflow files (don't want these in public repo)
          rm -f .github/workflows/publish-to-public.yml
          rm -f .github/workflows/auto-release.yml
          rm -f .github/workflows/auto-release.yaml
          rm -f .github/workflows/auto-tag-on-version-bump.yml
          echo "‚úì Removed private workflow files"

          echo ""
          echo "Files cleaned. Current status:"
          git status --short || true

      - name: Check if there are changes to commit
        id: check_changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit cleaned changes
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git add -A

          # Create commit message with cleaned attribution
          cat > /tmp/commit_msg.txt <<'EOF'
          Prepare for public release

          Remove private development files and prepare repository
          for public distribution.
          EOF

          git commit -F /tmp/commit_msg.txt
          echo "‚úì Changes committed"

      - name: Push to public repository
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
        run: |
          # Add public remote with token embedded
          git remote add public https://x-access-token:${GITHUB_TOKEN}@github.com/${PUBLIC_REPO}.git

          # Push to public repository
          # Use --force since we're rewriting history and don't have remote tracking
          GIT_ASKPASS=true git push public HEAD:${PUBLIC_BRANCH} --force

          echo ""
          echo "================================================================"
          echo "  Successfully published to ${PUBLIC_REPO}"
          echo "================================================================"
          echo ""
          echo "Public repository: https://github.com/${PUBLIC_REPO}"
          echo "Branch: ${PUBLIC_BRANCH}"

          # If we have a tag, push it to public repo
          if [ -n "${{ steps.detect_tag.outputs.tag_name }}" ]; then
            TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
            echo "Pushing tag: ${TAG_NAME}"
            git push public ${TAG_NAME} || echo "Note: Tag may already exist on public repo"
          fi

      - name: Create GitHub release on public repo
        if: steps.detect_tag.outputs.is_version_tag == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
          GH_REPO: ${{ env.PUBLIC_REPO }}
        run: |
          # Extract version from detected tag
          TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
          VERSION=${TAG_NAME#v}

          echo "Creating release for version: $VERSION"

          # Extract release notes from NEWS.md
          if [ -f "NEWS.md" ]; then
            # Extract the section for this version
            awk "/^# emburden $VERSION/,/^# emburden [0-9]/" NEWS.md | head -n -1 > /tmp/release-notes.md

            # If no release notes found, use a default message
            if [ ! -s /tmp/release-notes.md ]; then
              echo "Release notes not found in NEWS.md for version $VERSION" > /tmp/release-notes.md
            fi
          else
            echo "Release notes not available (NEWS.md not found)" > /tmp/release-notes.md
          fi

          # Append installation and citation information
          cat >> /tmp/release-notes.md <<EOF

          ---

          ## Installation

          \`\`\`r
          # Install from GitHub
          # install.packages("remotes")
          remotes::install_github("${PUBLIC_REPO}@${TAG_NAME}")
          \`\`\`

          ## Citation

          If you use this package or methodology in your research, please cite:

          **Scheier, E., & Kittner, N. (2022). A measurement strategy to address disparities across household energy burdens. _Nature Communications_, 13, 1717. https://doi.org/10.1038/s41467-021-27673-y**
          EOF

          # Create the release on public repo
          gh release create "${TAG_NAME}" \
            --repo "${PUBLIC_REPO}" \
            --title "emburden ${TAG_NAME}" \
            --notes-file /tmp/release-notes.md \
            --verify-tag

          echo ""
          echo "‚úÖ GitHub release created: https://github.com/${PUBLIC_REPO}/releases/tag/${TAG_NAME}"

      - name: Summary
        run: |
          echo "## Publication Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Successfully published to [\`${PUBLIC_REPO}\`](https://github.com/${PUBLIC_REPO})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target branch:** \`${PUBLIC_BRANCH}\`" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ steps.detect_tag.outputs.tag_name }}" ]; then
            TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
            echo "**Tag:** \`${TAG_NAME}\`" >> $GITHUB_STEP_SUMMARY

            # If this is a version tag, include release link
            if [[ "$TAG_NAME" == v* ]]; then
              echo "**Release:** [${TAG_NAME}](https://github.com/${PUBLIC_REPO}/releases/tag/${TAG_NAME})" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Cleaned items:" >> $GITHUB_STEP_SUMMARY
          echo "- \`.private/\` directory" >> $GITHUB_STEP_SUMMARY
          echo "- \`*.log\` files" >> $GITHUB_STEP_SUMMARY
          echo "- \`*_cache/\` directories" >> $GITHUB_STEP_SUMMARY
          echo "- \`*_files/\` directories" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow files" >> $GITHUB_STEP_SUMMARY
          echo "- AI attributions from commit messages" >> $GITHUB_STEP_SUMMARY

