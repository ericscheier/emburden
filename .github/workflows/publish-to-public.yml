name: Publish to Public Repository

# Trigger options:
# 1. On GitHub release published (automatic after auto-release.yaml creates release)
# 2. On push to 'ready-for-public' branch (create this branch with protections)
# 3. Manual trigger via GitHub Actions UI
#
# NOTE: We trigger on 'release' events instead of 'push: tags' because
# the auto-release workflow uses GITHUB_TOKEN to push tags, which won't
# trigger other workflows (GitHub security feature to prevent infinite loops).
# By triggering on 'release' events, we run automatically when the GitHub
# release is created.

on:
  release:
    types: [published]  # Triggers when auto-release.yaml creates a GitHub release
  workflow_call:  # NEW
    inputs:
      tag_name:
        required: true
        type: string

  push:
    branches:
      - 'ready-for-public'  # Protected branch for controlled releases
  workflow_dispatch:    # Manual trigger from GitHub UI
    inputs:
      tag_name:
        description: 'Tag name (e.g., v0.5.13) - optional, defaults to current HEAD'
        required: false
        type: string

env:
  PUBLIC_REPO: 'ericscheier/emburden'
  PUBLIC_BRANCH: 'main'

jobs:
  # Stage 1: Full CRAN validation with vignettes on private repo
  validate-cran:
    name: "Stage 1: CRAN Validation (Private Repo)"
    runs-on: ubuntu-latest
    # Only run CRAN validation for version tags
    if: |
      (github.event.release.tag_name != '' && startsWith(github.event.release.tag_name, 'v')) ||
      (inputs.tag_name != '' && startsWith(inputs.tag_name, 'v'))

    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tarball: ${{ steps.build.outputs.tarball }}
      tag_name: ${{ steps.tag.outputs.tag_name }}

    steps:
      - name: Detect tag
        id: tag
        run: |
          if [ -n "${{ github.event.release.tag_name }}" ]; then
            TAG="${{ github.event.release.tag_name }}"
          elif [ -n "${{ inputs.tag_name }}" ]; then
            TAG="${{ inputs.tag_name }}"
          else
            TAG=""
          fi
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT
          echo "Validating tag: $TAG"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.tag.outputs.tag_name }}
          fetch-depth: 0

      - name: Extract version from tag
        id: get_version
        run: |
          TAG="${{ steps.tag.outputs.tag_name }}"
          VERSION=${TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Found version: $VERSION"

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: 'release'
          use-public-rspm: true

      - name: Setup R dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: |
            any::rcmdcheck
            any::devtools
          needs: check

      - name: Setup Pandoc
        uses: r-lib/actions/setup-pandoc@v2

      - name: Setup TinyTeX
        uses: r-lib/actions/setup-tinytex@v2
        env:
          TINYTEX_INSTALLER: TinyTeX

      - name: Install LaTeX packages for vignettes
        run: |
          # Install LaTeX packages needed for JSS vignette
          tlmgr install xcolor xstring fancyvrb framed

      - name: Build source package
        id: build
        run: |
          # Run R CMD build and capture tarball name
          R CMD build . | tee /tmp/build-output.txt
          tarball=$(grep -o '[^/]*\.tar\.gz$' /tmp/build-output.txt)
          echo "tarball=$tarball" >> $GITHUB_OUTPUT
          echo "Built package: $tarball"

      - name: Run CRAN checks (full build with vignettes)
        run: |
          echo "ðŸ” STAGE 1: Full CRAN validation on private repo (with vignettes)"
          Rscript -e "rcmdcheck::rcmdcheck(
            path = '${{ steps.build.outputs.tarball }}',
            args = c('--as-cran', '--no-manual'),
            error_on = 'warning',
            check_dir = 'check'
          )"

      - name: Upload check results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: private-cran-check-results
          path: check/

      - name: Upload source tarball
        uses: actions/upload-artifact@v4
        with:
          name: r-package-source
          path: ${{ steps.build.outputs.tarball }}
          retention-days: 30

      - name: Submit to Win-builder (Optional)
        id: winbuilder
        continue-on-error: true
        run: |
          echo "ðŸ“¦ Submitting to Win-builder for Windows testing..."
          Rscript -e "devtools::check_win_release(email = '${{ secrets.CRAN_EMAIL }}')"
          echo "âœ… Submitted to Win-builder!"

  # Stage 2: Testing dry-run - runs automatically after validation
  dry-run-test:
    name: "Stage 2: Testing Dry-Run (Private Repo)"
    needs: validate-cran
    if: success()
    runs-on: ubuntu-latest
    environment: cran-testing  # No approval required

    steps:
      - name: Download package tarball
        uses: actions/download-artifact@v4
        with:
          name: r-package-source

      - name: Dry-run validation
        env:
          CRAN_EMAIL: ${{ secrets.CRAN_EMAIL }}
        run: |
          VERSION="${{ needs.validate-cran.outputs.version }}"
          TARBALL="${{ needs.validate-cran.outputs.tarball }}"

          echo "ðŸ” STAGE 2: Testing Dry-Run (Private Repo)"
          echo ""
          echo "Package: emburden v$VERSION"
          echo "Tarball: $TARBALL"
          echo "Email: $CRAN_EMAIL"
          echo ""
          echo "âœ… Package validated successfully"
          echo "âœ… Vignettes built successfully"
          echo "âœ… All checks passed"
          echo ""
          echo "ðŸ“‹ Sequential Pipeline Progress:"
          echo "  âœ… Stage 1: Full CRAN validation complete (with vignettes)"
          echo "  âœ… Stage 2: Testing dry-run complete (current)"
          echo "  â³ Stage 3: Production dry-run (requires approval)"
          echo "  â³ Stage 4: Publish to public repo (automatic after approval)"

  # Stage 3: Production dry-run - requires approval before publishing
  dry-run-prod:
    name: "Stage 3: Production Dry-Run (Approval Required)"
    needs: [validate-cran, dry-run-test]
    if: success()
    runs-on: ubuntu-latest
    environment: cran-production  # Requires manual approval

    steps:
      - name: Download package tarball
        uses: actions/download-artifact@v4
        with:
          name: r-package-source

      - name: Production dry-run preview
        env:
          CRAN_EMAIL: ${{ secrets.CRAN_EMAIL }}
        run: |
          VERSION="${{ needs.validate-cran.outputs.version }}"
          TARBALL="${{ needs.validate-cran.outputs.tarball }}"

          echo "ðŸ” STAGE 3: Production Dry-Run (Approval Granted)"
          echo ""
          echo "Package: emburden v$VERSION"
          echo "Tarball: $TARBALL"
          echo "Email: $CRAN_EMAIL"
          echo "Environment: cran-production (private repo)"
          echo ""
          echo "âœ… Package validated successfully"
          echo "âœ… Vignettes built successfully"
          echo "âœ… All checks passed"
          echo "âœ… Production approval granted"
          echo ""
          echo "ðŸ“‹ Sequential Pipeline Progress:"
          echo "  âœ… Stage 1: Full CRAN validation complete"
          echo "  âœ… Stage 2: Testing dry-run complete"
          echo "  âœ… Stage 3: Production dry-run complete (current)"
          echo "  â³ Stage 4: Publish to public repo (ready to proceed)"
          echo ""
          echo "ðŸ“Œ Ready to publish to public repository!"

  # Stage 4: Publish to public repo - only after all validation and approval
  publish:
    name: "Stage 4: Publish to Public Repository"
    runs-on: ubuntu-latest
    needs: [validate-cran, dry-run-prod]
    # Run if all previous stages succeeded OR if not a version tag (skip validation for branch pushes)
    if: |
      always() &&
      (needs.dry-run-prod.result == 'success' || needs.validate-cran.result == 'skipped')
    environment:
      name: public-release
      url: https://github.com/${{ env.PUBLIC_REPO }}

    steps:
      - name: Detect tag name from input or event
        id: detect_tag
        run: |
          # Priority: workflow_dispatch/workflow_call input > tag event > branch
          if [ -n "${{ inputs.tag_name }}" ]; then
            TAG_NAME="${{ inputs.tag_name }}"
            echo "Source: workflow input"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "Source: tag event"
          else
            TAG_NAME=""
            echo "Source: branch (no tag)"
          fi

          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "is_tag=$( [ -n \"$TAG_NAME\" ] && echo \"true\" || echo \"false\" )" >> $GITHUB_OUTPUT
          echo "is_version_tag=$( [[ \"$TAG_NAME\" == v* ]] && echo \"true\" || echo \"false\" )" >> $GITHUB_OUTPUT

          if [ -n "$TAG_NAME" ]; then
            echo "Detected tag: $TAG_NAME"
          else
            echo "No tag detected - will publish current branch"
          fi

      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.detect_tag.outputs.tag_name || github.ref }}
          fetch-depth: 0  # Full history for proper git operations
          persist-credentials: false  # Don't persist GitHub Actions token

      - name: Configure git
        run: |
          git config user.name "Eric Scheier"
          git config user.email "eric@scheier.org"

      - name: Install git-filter-repo
        run: |
          python3 -m pip install --user git-filter-repo

      - name: Filter AI attributions from commit messages
        run: |
          echo "Rewriting commit history to remove AI attributions..."

          # Create Python script to filter commit messages
          cat > /tmp/filter-commit-messages.py <<'PYTHON_EOF'
          #!/usr/bin/env python3
          import re
          import sys

          # Read the commit message
          message = sys.stdin.buffer.read().decode('utf-8')

          # Remove AI attribution lines
          # Pattern 1: Full attribution block with emoji and Co-Authored-By
          message = re.sub(r'\n\nðŸ¤– Generated with \[Claude Code\]\(https://claude\.com/claude-code\)\n\nCo-Authored-By: Claude <noreply@anthropic\.com>\n?', '', message)

          # Pattern 2: Just the Claude Code line
          message = re.sub(r'\n\nðŸ¤– Generated with \[Claude Code\]\(https://claude\.com/claude-code\)\n?', '', message)

          # Pattern 3: Just the Co-Authored-By line
          message = re.sub(r'\n\nCo-Authored-By: Claude <noreply@anthropic\.com>\n?', '', message)

          # Clean up any trailing whitespace and multiple blank lines
          message = re.sub(r'\n\n\n+', '\n\n', message)
          message = message.rstrip() + '\n'

          # Output the cleaned message
          sys.stdout.buffer.write(message.encode('utf-8'))
          PYTHON_EOF

          chmod +x /tmp/filter-commit-messages.py

          # Apply filter to all commits
          ~/.local/bin/git-filter-repo --force \
            --commit-callback "$(cat <<'CALLBACK_EOF'
          import subprocess

          # Get the original message
          original_msg = commit.message.decode('utf-8')

          # Filter it through our Python script
          result = subprocess.run(
              ['/tmp/filter-commit-messages.py'],
              input=original_msg.encode('utf-8'),
              capture_output=True
          )

          # Update the commit message
          commit.message = result.stdout
          CALLBACK_EOF
          )"

          echo "âœ“ Commit history rewritten - AI attributions removed"

      - name: Clean repository for public release
        run: |
          echo "Cleaning repository for public distribution..."

          # Remove .private/ directory
          if [ -d ".private" ]; then
            rm -rf .private/
            echo "âœ“ Removed .private/ directory"
          fi

          # Remove log files
          find . -name "*.log" -type f -delete 2>/dev/null || true
          echo "âœ“ Removed *.log files"

          # Remove cache directories
          find . -name "*_cache" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "âœ“ Removed *_cache directories"

          # Remove output directories
          find . -name "*_files" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "âœ“ Removed *_files directories"

          # Remove private-only workflow files (don't want these in public repo)
          rm -f .github/workflows/publish-to-public.yml
          rm -f .github/workflows/auto-release.yml
          rm -f .github/workflows/auto-release.yaml
          rm -f .github/workflows/auto-tag-on-version-bump.yml
          echo "âœ“ Removed private workflow files"

          echo ""
          echo "Files cleaned. Current status:"
          git status --short || true

      - name: Check if there are changes to commit
        id: check_changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit cleaned changes
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          git add -A

          # Create commit message with cleaned attribution
          cat > /tmp/commit_msg.txt <<'EOF'
          Prepare for public release

          Remove private development files and prepare repository
          for public distribution.
          EOF

          git commit -F /tmp/commit_msg.txt
          echo "âœ“ Changes committed"

      - name: Push to public repository
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
        run: |
          # Add public remote with token embedded
          git remote add public https://x-access-token:${GITHUB_TOKEN}@github.com/${PUBLIC_REPO}.git

          # Push to public repository
          # Use --force since we're rewriting history and don't have remote tracking
          GIT_ASKPASS=true git push public HEAD:${PUBLIC_BRANCH} --force

          echo ""
          echo "================================================================"
          echo "  Successfully published to ${PUBLIC_REPO}"
          echo "================================================================"
          echo ""
          echo "Public repository: https://github.com/${PUBLIC_REPO}"
          echo "Branch: ${PUBLIC_BRANCH}"

          # If we have a tag, push it to public repo
          if [ -n "${{ steps.detect_tag.outputs.tag_name }}" ]; then
            TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
            echo "Pushing tag: ${TAG_NAME}"
            git push public ${TAG_NAME} || echo "Note: Tag may already exist on public repo"
          fi

      - name: Create GitHub release on public repo
        if: steps.detect_tag.outputs.is_version_tag == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_TOKEN }}
          GH_REPO: ${{ env.PUBLIC_REPO }}
        run: |
          # Extract version from detected tag
          TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
          VERSION=${TAG_NAME#v}

          echo "Creating release for version: $VERSION"

          # Extract release notes from NEWS.md
          if [ -f "NEWS.md" ]; then
            # Extract the section for this version
            awk "/^# emburden $VERSION/,/^# emburden [0-9]/" NEWS.md | head -n -1 > /tmp/release-notes.md

            # If no release notes found, use a default message
            if [ ! -s /tmp/release-notes.md ]; then
              echo "Release notes not found in NEWS.md for version $VERSION" > /tmp/release-notes.md
            fi
          else
            echo "Release notes not available (NEWS.md not found)" > /tmp/release-notes.md
          fi

          # Append installation and citation information
          cat >> /tmp/release-notes.md <<EOF

          ---

          ## Installation

          \`\`\`r
          # Install from GitHub
          # install.packages("remotes")
          remotes::install_github("${PUBLIC_REPO}@${TAG_NAME}")
          \`\`\`

          ## Citation

          If you use this package or methodology in your research, please cite:

          **Scheier, E., & Kittner, N. (2022). A measurement strategy to address disparities across household energy burdens. _Nature Communications_, 13, 1717. https://doi.org/10.1038/s41467-021-27673-y**
          EOF

          # Create the release on public repo
          gh release create "${TAG_NAME}" \
            --repo "${PUBLIC_REPO}" \
            --title "emburden ${TAG_NAME}" \
            --notes-file /tmp/release-notes.md \
            --verify-tag

          echo ""
          echo "âœ… GitHub release created: https://github.com/${PUBLIC_REPO}/releases/tag/${TAG_NAME}"

      - name: Summary
        run: |
          echo "## Publication Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Successfully published to [\`${PUBLIC_REPO}\`](https://github.com/${PUBLIC_REPO})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target branch:** \`${PUBLIC_BRANCH}\`" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ steps.detect_tag.outputs.tag_name }}" ]; then
            TAG_NAME="${{ steps.detect_tag.outputs.tag_name }}"
            echo "**Tag:** \`${TAG_NAME}\`" >> $GITHUB_STEP_SUMMARY

            # If this is a version tag, include release link
            if [[ "$TAG_NAME" == v* ]]; then
              echo "**Release:** [${TAG_NAME}](https://github.com/${PUBLIC_REPO}/releases/tag/${TAG_NAME})" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Cleaned items:" >> $GITHUB_STEP_SUMMARY
          echo "- \`.private/\` directory" >> $GITHUB_STEP_SUMMARY
          echo "- \`*.log\` files" >> $GITHUB_STEP_SUMMARY
          echo "- \`*_cache/\` directories" >> $GITHUB_STEP_SUMMARY
          echo "- \`*_files/\` directories" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow files" >> $GITHUB_STEP_SUMMARY
          echo "- AI attributions from commit messages" >> $GITHUB_STEP_SUMMARY

