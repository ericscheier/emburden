---
title: "NERC Market Snapshot"
output: html_document
date: "`r Sys.Date()`"
---

```{r echo=FALSE}
knitr::opts_chunk$set(
  echo=FALSE,
  fig.keep='all',
  cache=TRUE
  )
```


```{r,  cache=FALSE, include=FALSE}
source("MarketFigures.R")
```

```{r,  include=FALSE}
SERC_REGIONS <- c("SERC RELIABILITY CORPORATION (SERC)",
                                   "FLORIDA RELIABILITY COORDINATING COUNCIL (FRCC)")

re_pattern <- "(?<=\\().+?(?=\\))"

nerc_regions <- sf::st_read("data/nerc_regions.gdb") %>% 
                st_transform(., 4326) %>% 
  mutate(
    newNAME=ifelse(NAME %in% SERC_REGIONS, SERC_REGIONS[1], NAME)
  ) %>% 
  mutate(
    shortNAME=str_extract(newNAME, re_pattern)
  ) %>% 
  unite(
    subNAME, shortNAME, SUBNAME, sep="_", remove=FALSE
  )
```

```{r}
# plot((nerc_regions["NAME"]))#, col = sf.colors(categorical = TRUE, alpha = .5))
nerc_regions %>% ggplot() +
    ggplot2::geom_sf(aes(fill = shortNAME))
```

```{r eval=FALSE}


plot((nerc_regions["NAME"] %>% filter(NAME %in% SERC_REGIONS)))#, col = sf.colors(categorical = TRUE, alpha = .5))
```

```{r}
#library(stringr)
# Get the parenthesis and what is inside
#k <- str_extract_all(j, "\\([^()]+\\)")[[1]]

# Remove parenthesis
#k <- substring(k, 2, nchar(k)-1)

agg_nerc_sub <- nerc_regions %>%
  group_by(subNAME, shortNAME) %>% 
  # st_union() %>% 
  summarize(
    # shortNAME = mode(shortNAME)
  )

agg_nerc <- agg_nerc_sub %>%
  group_by(shortNAME) %>% 
  # st_union() %>% 
  summarize()
```

```{r}
agg_nerc_sub %>% ggplot() +
    ggplot2::geom_sf(aes(fill = subNAME, line=shortNAME))
```
```{r}
overlap_function <- function(tract, regions) {
  # reproject the inputs to a common crs
  tract <- st_transform(tract, crs = st_crs(regions))
  
  # calculate the area of intersection between the tract and each region
  overlaps <- st_intersection(st_geometry(regions), st_geometry(tract)) %>% 
    st_area()
  
  # get the index of the region with the largest overlap
  max_index <- which.max(overlaps)
  
    
  if (is.null(max_index)) {
    return(NA)
  } else {
    return(as.numeric(as.character(max_index)))
  }
}


library(progressr)
library(foreach)
library(doParallel)

find_max_overlap <- function(tracts, regions) {
  tracts <- st_geometry(tracts)
  regions <- st_geometry(regions)
  
  # create a progress bar object
  # pb <- progressor(steps = nrow(tracts), message = "Processing tracts...")
  
  # apply overlap_function to each tract in the tracts data frame
  indices <- lapply(1:length(tracts), function(i) {
    # increment the progress bar for each tract
    # pb$tick()
    
    overlap_function(tracts[i], regions)
    # overlap_function(st_geometry(tracts[i,]), regions)
  })
  
  # return the vector of indices
  return(unlist(indices))
}

find_max_overlap_parallel <- function(tracts, regions, 
                                      export = c("overlap_function"),
                                      packages = c("dplyr", "tidyr", "sf")
                                      ) {
  # set up parallel processing
  cl <- makeCluster(max(1,detectCores()-1))
  registerDoParallel(cl)#, .export=export, .packages=packages)
  
  tracts <- st_geometry(tracts)
  regions <- st_geometry(regions)
  
  # create a progress bar object
  # pb <- progressor(steps = length(tracts), message = "Processing tracts...")
  
  # apply overlap_function to each tract in the tracts data frame in parallel
  indices <- foreach(i = 1:length(tracts), .combine = "c", .export=export, .packages=packages) %dopar% {
    # increment the progress bar for each tract
    # pb$tick()
    overlap_function(tracts[i], regions)
    # overlap_function(st_geometry(tracts[i,]), regions)
  }
  
  # stop parallel processing and return the vector of indices
  stopCluster(cl)
  return(indices)
}

# find_max_overlap <- function(tracts, regions) {
#   # tracts <- st_geometry(tracts)
#   regions <- st_geometry(regions)
#   # apply overlap_function to each tract in the tracts data frame
#   indices <- lapply(1:nrow(tracts), function(i) {
#     overlap_function(st_geometry(tracts[i,]), regions)
#   })
#   
#   # return the vector of indices
#   return(unlist(indices))
# }
```


```{r eval=FALSE}
# find the index of the region that overlaps the most with each tract
nrun=1000
tot_rows=nrow(clean_data_ami_all_sup_shp)
shape_subset <- clean_data_ami_all_sup_shp[runif(nrun, min=1, max=tot_rows),]
```

```{r}
shape_subset <- clean_data_ami_all_sup_shp %>% 
  filter(!state_abbr %in% c("AK","HI")) %>%
  select(state_abbr, geometry) %>%
  group_by(state_abbr) %>% summarize()
  #summarize(geometry = st_union(geometry))

agg_nerc
```


```{r}
# time the duration of the function
start_time <- system.time({
  # result <- my_function(5)
  
  max_indices <- find_max_overlap_parallel(tracts=shape_subset %>% drop_na(), 
                                regions=agg_nerc)
})[["elapsed"]]

# print the result and duration
cat("Result:", max_indices, "\n")
cat("Duration:", start_time, "seconds\n")
#cat("Rows: ",nrun," of ",tot_rows,"\n")
#exp_secs = (start_time/nrun)*tot_rows
#cat("Expected Duration:",exp_secs,"seconds (",exp_secs/60,"minutes)\n")

# do something with the max_indices, such as adding them as a new column to the tracts data frame
# tracts$max_index <- max_indices

name_cols <- grep("NAME", names(agg_nerc), value = TRUE)
  
region_names <- agg_nerc[, name_cols] %>% st_drop_geometry()

cbind(shape_subset %>% drop_na(),
      region_names[max_indices,]) %>% ggplot() + 
  ggplot2::geom_sf(aes(fill = shortNAME, line=shortNAME))
```


```{r}
# overlap_function <- function(tract_index, tracts, regions) {
#   # get the specific tract of interest
#   tract <- tracts[tract_index,]
#   
#   # calculate the area of intersection between the tract and each region
#   overlaps <- st_intersection(regions, tract) %>% 
#     st_area()
#   
#   # get the index of the region with the largest overlap
#   max_index <- which.max(overlaps)
#   
#   return(region_names)
# }

overlap_function <- function(tract, regions, region_names) {
  # calculate the area of intersection between the tract and each region
  overlaps <- st_intersection(regions, tract) %>% 
    st_area()
  
  # get the index of the region with the largest overlap
  max_index <- which.max(overlaps)
  print(max_index)
  return(max_index)
}



clean_data_ami_all_sup_shp[1:10,] %>% rowwise() %>% 
  mutate(
    max_index = overlap_function(geometry, agg_nerc_sub, region_names)
  ) %>% select(max_index)

apply(clean_data_ami_all_sup_shp[1:10,] %>% 
        # head(10) %>% 
        # st_as_sf(crs = st_crs(clean_data_ami_all_sup_shp)) %>% 
        st_transform(4326),
      1, overlap_function, regions=agg_nerc_sub, #%>% 
        # st_transform(4326), 
      region_names=region_names)
```


```{r}
# determine the region that overlaps most with the first tract
overlap_function(58000, clean_data_ami_all_sup_shp, agg_nerc_sub)

sapply(runif(100, min=1, max=nrow(clean_data_ami_all_sup_shp)),
      # 2,
      overlap_function,
      tracts=clean_data_ami_all_sup_shp,
      regions=agg_nerc_sub
      )
```


```{r,  results='hide'}
# intersect - note that sf is intelligent with attribute data!
serc_subset <- st_intersection(clean_data_ami_all_sup_shp, 
              agg_nerc %>% 
                filter(shortNAME=="SERC")
                )
```


```{r}
# plot(serc_subset$geometry)
serc_subset %>% ggplot() +
    ggplot2::geom_sf(aes(fill = simplified_utility_type), color=NA)
```
```{r}
library(kableExtra)

market_snapshot_summary <- function(x){
  x  %>% 
  summarize(
    ave_elec_spend = mean(electricity_spend, na.rm = TRUE),
    ave_energy_spend = mean(energy_cost, na.rm=TRUE),
    total_households = sum(households, na.rm=TRUE)
  ) %>% 
  mutate(
    total_elec_spend = ave_elec_spend * total_households,
    total_energy_spend = ave_energy_spend * total_households
  ) %>% 
  mutate(
    elec_rev_share = total_elec_spend / sum(total_elec_spend, na.rm=TRUE),
    energy_spend_share = total_energy_spend / sum(total_energy_spend, na.rm=TRUE),
    customer_share = total_households / sum(total_households, na.rm=FALSE)
  ) %>% 
  arrange(
    desc(energy_spend_share)
  ) %>% 
  mutate(
    ave_elec_spend = to_dollar(ave_elec_spend),
    ave_energy_spend = to_dollar(ave_energy_spend),
    total_households = to_million(total_households),
    total_elec_spend = to_billion_dollar(total_elec_spend),
    total_energy_spend = to_billion_dollar(total_energy_spend),
    elec_rev_share = to_percent(elec_rev_share),
    energy_spend_share = to_percent(energy_spend_share),
    customer_share = to_percent(customer_share)
  ) %>% kable(., "html") %>% kable_styling("striped") %>% scroll_box(width = "100%", height="100px")
}
```

### Total across SERC

```{r}
serc_subset %>% st_drop_geometry() %>% market_snapshot_summary()
```

### By State

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  state_abbr
) %>% market_snapshot_summary()
```

### By Distribution Utility Type (Simplified)

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  simplified_utility_type
) %>% market_snapshot_summary()
```

```{r}
serc_subset %>% st_drop_geometry() %>% 
  group_by(
    simplified_utility_type
  ) %>% 
  summarise(
    number_of_utilities = n_distinct(company_na)
  ) %>% arrange(
    desc(number_of_utilities)
  )
    
#%>% market_snapshot_summary()
```

### By Distribution Utility Type (Not Simplified)

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  company_ty
) %>% market_snapshot_summary()
```

### By Distribution Utility Name

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  company_na
) %>% market_snapshot_summary()
```

### By Locale (Simplified)

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  simplified_locale
) %>% market_snapshot_summary()
```

### By Housing Tenure

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  housing_tenure
) %>% market_snapshot_summary()
```

### By Income Bracket

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  income_bracket
) %>% market_snapshot_summary()
```

### By Number of Units Per Building

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  number_of_units
) %>% market_snapshot_summary()
```

### By Climate Zone

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  climate_zone_description
) %>% market_snapshot_summary()
```

### By Whether a Household is in Income Poverty

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  in_poverty
) %>% market_snapshot_summary()
```

### Breakdown by whether in energy poverty according to energy burden > 6%

```{r}
serc_subset %>% st_drop_geometry() %>% group_by(
  energy_burden_poverty
) %>% market_snapshot_summary()
```


```{r comparison-table-math, eval=FALSE}
# table with states'/groups' median annual household energy expenditures, incomes, net incomes, *N~h~*, and *E~b~*
compare_metrics <- function(metric_name="ner",
                            dataset=NULL
                            ){
  gwm <- calculate_weighted_metrics(filter_graph_data(dataset,c("income_bracket"),metric_name),
                           c("income_bracket"),
                           metric_name,
                           metric_cutoff_level=0,
                           upper_quantile_view = 1,
                           lower_quantile_view=0)
  gwm$metric_name <- metric_name
  return(gwm)
}

create_comparison_table <- function(
    metrics_to_compare=c("income",
                         "energy_cost",
                         # "energy_burden",
                         "net_income"#,
                         # "ner"
                                    ),
    dataset=NULL,
    include_totals=TRUE
){
  minimum_metrics_to_compare <- c("income","energy_cost","net_income")
  
  metrics_to_compare <- unique(c(metrics_to_compare,minimum_metrics_to_compare))
  
  compare_table <- data.table::rbindlist(lapply(metrics_to_compare, 
                                                compare_metrics,
                                      dataset=clean_data_ami))
  
  
  compare_table <- compare_table %>% 
    pivot_wider(id_cols=income_bracket,
                names_from=metric_name,
                values_from=metric_mean) %>% 
    mutate(energy_burden = energy_burden_func(g=income, s=energy_cost),
           ner = ner_func(g=income, s=energy_cost)) %>% 
    pivot_longer(cols=unique(c("income","energy_cost","energy_burden","net_income","ner"), 
                             minimum_metrics_to_compare))
  
  if(include_totals){
    compare_table_totals <- compare_table %>% 
    filter(metric_name=="income") %>% 
    pivot_wider(id_cols=income_bracket,
                names_from=metric_name,
                values_from=household_count,
                ) %>% 
    rename(households=income) %>% pivot_longer(cols="households")
    
    compare_table <- rbind(compare_table_totals, compare_table)
  }
  
  #format the metrics accordingly
  # income = 0 decimal place $
  # energy_cost = 0 decimal place $
  # energy_burden = 0 decimal place %
  # net_income = 0 decimal place $
  # ner = 1 decimal place number
  
  which_metric <- "value" #"metric_mean" #"metric_median"
  
  compare_table$print_value <- ifelse(compare_table$name %in% c("income",
                                                                       "energy_cost",
                                                                       "net_income"),
                                      to_dollar(compare_table[[which_metric]],latex=TRUE),
                                      ifelse(compare_table$name %in% c("energy_burden"),
                                             to_percent(compare_table[[which_metric]],latex=TRUE),
                                             ifelse(compare_table$name %in% c("ner"),
                                                    round(compare_table[[which_metric]],1),
                                                    ifelse(compare_table$name %in% c("households"),
                                                           to_million(compare_table[[which_metric]]),
                                                    to_big(compare_table[[which_metric]])))))
  
  compare_table$display_income_bracket <- dplyr::recode_factor(compare_table$income_bracket, 
                                         very_low="0-30\\% AMI",
                                         low_mod="30-80\\% AMI", 
                                         mid_high="Above 80\\% AMI",
                                         All="All",
                                         .ordered=TRUE)
  
  energy_burden_label <- "\\textit{E\\textsubscript{b}} (\\textit{S}/\\textit{G})" #if html etc. <- "*E~b~* (S/G)"
  ner_label <- "\\textit{N\\textsubscript{h}} ([\\textit{G}-\\textit{S}]/\\textit{S})" #if html etc. <- "*N~h~* ([G-S]/S)"
  
  compare_table[,"Metric Name"] <- dplyr::recode(compare_table$name,
                                                 households="Households in Sample",
                                      income="Annual Income (\\textit{G})",
                                      energy_cost="Annual Energy Expenditures (\\textit{S})",
                                      energy_burden=energy_burden_label,
                                      net_income="Net Income (\\textit{G}-\\textit{S})",
                                      ner=ner_label)
  
  print_table <- compare_table[,c("Metric Name","display_income_bracket","print_value")] %>% 
    arrange(display_income_bracket) %>% 
    pivot_wider(names_from=display_income_bracket,values_from=print_value)
  
  return(print_table)
}

print_table <- create_comparison_table <- function(
    metrics_to_compare=NULL,
    dataset=NULL,
    include_totals=TRUE
)
  
write_csv(print_table, "comparison_table.csv")

highlight_metrics <- rbindlist(lapply(c(
                                    "energy_burden",
                                    "ner"
                                    ), compare_metrics,
                                    dataset=clean_data_ami))

highlight_energy_burden <- as.numeric(highlight_metrics[metric_name=="energy_burden" & income_bracket=="very_low","metric_mean"])

highlight_ner <- as.numeric(highlight_metrics[metric_name=="ner" & income_bracket=="very_low","metric_mean"])

num_one <- paste0(to_big(highlight_energy_burden*100),"\\%")
num_two <- round(highlight_ner,1)
# glue::glue(
```

```{r comparison-table, include=TRUE, results="asis", eval=FALSE}
final_table <- subset(print_table, select=-All) %>%  
  knitr::kable(booktabs=T,
               escape = F,
               caption='(ref:comparison-table-caption)') %>% 
  kableExtra::kable_styling(latex_options = "H") %>% 
  kableExtra::add_footnote(
    # input,
    label = c(
      "AMI: Area Median Income",
      #"*E~b~*: Energy Burden",
      #"*N~h~*: Net Energy Return",
      "\\textit{N\\textsubscript{h}}: Household Net Energy Return",
      "\\textit{E\\textsubscript{b}}: Household Energy Burden"
              ),
    notation = "none", #number, alphabet, symbol and none
    threeparttable = FALSE,
    escape = FALSE
    )
  # kableExtra::row_spec(c(2,3,4,6), bold=T)
  # kableExtra::kable_styling(latex_options = c("striped"), #,"hold_position"
                            # position="center")
final_table
```